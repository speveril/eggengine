// Library function implementation, LLVM-style.

// See script_LLVM for more ramblings about the LLVM ScriptEngine.

// Turn off warnings generated by LLVM; I don't really care to fix them and I don't
// want them clogging up my compile output.
#pragma warning(disable:4146)
#pragma warning(disable:4996)
#pragma warning(disable:4800)

#include "core.h"
#include "script.h"

#include "llvm/Linker.h"
#include "llvm/LLVMContext.h"
#include "llvm/Module.h"
#include "llvm/DerivedTypes.h"
#include "llvm/Constants.h"
#include "llvm/Instructions.h"
#include "llvm/ModuleProvider.h"
#include "llvm/Analysis/Verifier.h"
#include "llvm/ExecutionEngine/ExecutionEngine.h"
#include "llvm/ExecutionEngine/Interpreter.h"
#include "llvm/ExecutionEngine/JIT.h"
#include "llvm/ExecutionEngine/GenericValue.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Support/MemoryBuffer.h"
#include "llvm/System/DynamicLibrary.h"
#include "llvm/Bitcode/ReaderWriter.h"

// use the llvm namespace so we're not forever typing "llvm::"
using namespace llvm;

#define SCRIPT_FUNCTION(FUNC_NAME) GenericValue FUNC_NAME(FunctionType *ft, const std::vector<GenericValue> &args)

static GenericValue nullGV;

// - Testing Built In Functions -

SCRIPT_FUNCTION(testCall) {
	Log::debug("testCall() has executed.");
	return nullGV;
}

SCRIPT_FUNCTION(addOne) {
	GenericValue returnValue;
	returnValue.DoubleVal = args[0].DoubleVal + 1;

	Log::debug("addOne() executed. Returning %g + 1 = %g", args[0].DoubleVal, returnValue.DoubleVal);
	
	return returnValue;
}

SCRIPT_FUNCTION(writeNumberToLog) {
	Log::write("%g", args[0].DoubleVal);
	return nullGV;
}

SCRIPT_FUNCTION(writeStringToLog) {
	Log::write((char *)args[0].PointerVal);
	return nullGV;
}

// - Memory Management Functions -

SCRIPT_FUNCTION(eggfunc_delete) {
	delete args[0].PointerVal;
	return nullGV;
}

// - Graphics Built In Functions -

SCRIPT_FUNCTION(eggfunc_getResolutionX) {
	GenericValue returnValue;
	returnValue.DoubleVal = core->screen->getWidth();
	return returnValue;
}

SCRIPT_FUNCTION(eggfunc_getResolutionY) {
	GenericValue returnValue;
	returnValue.DoubleVal = core->screen->getHeight();
	return returnValue;
}

SCRIPT_FUNCTION(eggfunc_newRenderStack) {
	GenericValue returnValue;
	returnValue.PointerVal = new std::vector<Layer *>;
	return returnValue;
}

SCRIPT_FUNCTION(eggfunc_setRenderStack) {
	core->renderEngine->setRenderStack((RenderStack *)args[0].PointerVal);
	return nullGV;
}

SCRIPT_FUNCTION(eggfunc_newLayer) {
	GenericValue returnValue;
	returnValue.PointerVal = new Layer(args[0].DoubleVal, args[1].DoubleVal, args[2].DoubleVal, args[3].DoubleVal);
	return returnValue;
}

SCRIPT_FUNCTION(eggfunc_newSprite) {
	return nullGV;
}

// ---

void ScriptEngine::registerEggLibraryFunctions() {
	registerFunction(testCall, "testCall", VoidType);
	registerFunction(writeStringToLog, "log", VoidType, 1, PointerType);
	registerFunction(writeNumberToLog, "logNumber", VoidType, 1, NumberType);
	registerFunction(addOne, "addOne", NumberType, 1, NumberType);

	registerFunction(eggfunc_delete, "delete", VoidType, 1, PointerType);

	registerFunction(eggfunc_getResolutionX, "getResolutionX", NumberType);
	registerFunction(eggfunc_getResolutionY, "getResolutionY", NumberType);
	registerFunction(eggfunc_newRenderStack, "newRenderStack", PointerType);
	registerFunction(eggfunc_setRenderStack, "setRenderStack", VoidType, 1, PointerType);
	registerFunction(eggfunc_newLayer, "newLayer", PointerType, 4, NumberType, NumberType, NumberType, NumberType);
}
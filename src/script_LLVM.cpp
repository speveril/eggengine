// LLVM-based ScriptEngine implementation.

// Will I write any other ScriptEngine implementations in the future? It is unclear!
// I don't really see the point, since LLVM gives us a fast VM that we can target
// with other compilers, so... why would we?

// Turn off warnings generated by LLVM; I don't really care to fix them and I don't
// want them clogging up my compile output.
#pragma warning(disable:4146)
#pragma warning(disable:4996)
#pragma warning(disable:4800)

#include <cstdarg>

#include "core.h"
#include "script.h"

#include "llvm/Linker.h"
#include "llvm/LLVMContext.h"
#include "llvm/Module.h"
#include "llvm/DerivedTypes.h"
#include "llvm/Constants.h"
#include "llvm/Instructions.h"
#include "llvm/ModuleProvider.h"
#include "llvm/Analysis/Verifier.h"
#include "llvm/ExecutionEngine/ExecutionEngine.h"
#include "llvm/ExecutionEngine/Interpreter.h"
#include "llvm/ExecutionEngine/JIT.h"
#include "llvm/ExecutionEngine/GenericValue.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Support/MemoryBuffer.h"
#include "llvm/System/DynamicLibrary.h"
#include "llvm/Bitcode/ReaderWriter.h"

// use the llvm namespace so we're not forever typing "llvm::"
using namespace llvm;

#define ENDARGS ((Type *)0)

// ---

typedef struct LLVMScriptEngineInternals {
	LLVMContext *context;
	Module *module;
	ExecutionEngine *exec;
	Type *pointerType;
} Internals;

ScriptEngine::ScriptEngine() {
	Log::debug("Constructing LLVM ScriptEngine.");

	internals = malloc(sizeof(Internals));
	Internals *i = (Internals *)internals;

	i->context = new LLVMContext();
	i->module = new Module("global", *i->context);
	i->exec = EngineBuilder(i->module).create();

	if (i->module->getPointerSize() == i->module->Pointer32)
		i->pointerType = (Type *)Type::getInt32Ty(*i->context);
	else if (i->module->getPointerSize() == i->module->Pointer64)
		i->pointerType = (Type *)Type::getInt64Ty(*i->context);

	//debug();
	registerEggLibraryFunctions();

	Log::debug("Done constructing LLVM ScriptEngine.");
}

ScriptEngine::~ScriptEngine() {
	Log::debug("Destroying LLVM ScriptEngine.");
	delete (Internals *)internals;
	Log::debug("Done destroying LLVM ScriptEngine.");
}

bool ScriptEngine::registerFunction(void *func, const char *name, ScriptEngine::type returnType, unsigned int argc, ...) {
	Log::debug("Register scripting function '%s'", name);

	Internals *i = (Internals *)internals;
	
	std::string symbolName = "lle_X_";
	symbolName += name;
	sys::DynamicLibrary::AddSymbol(symbolName, func);

	Type *r = 0;
	switch (returnType) {
		case VoidType: r = (Type *)Type::getVoidTy(*i->context); break;
		case NumberType: r = (Type *)Type::getDoubleTy(*i->context); break;
		case PointerType: r = i->pointerType; break;
		default: break;
	}

	FunctionType *ft = 0;

	if (argc < 1) {
		ft = FunctionType::get(r, false);
	} else {
		std::vector<const Type*> p;
		va_list args;

		va_start(args, argc);
		for (unsigned int x = 0; x < argc; x++) {
			switch ( va_arg(args, ScriptEngine::type) ) {
				case VoidType: p.push_back(Type::getVoidTy(*i->context)); break;
				case NumberType: p.push_back(Type::getDoubleTy(*i->context)); break;
				default: break;
			}
		}
		va_end(args);

		ft = FunctionType::get(r, p, false);
	}

	Function *f = Function::Create(ft, Function::ExternalLinkage, name, i->module);

	Log::debug("Done registering function '%s'", name);

	return true;
}


bool ScriptEngine::loadFile(const char *filename) {
	Internals *i = (Internals *)internals;

	Log::debug("Load file %s.", filename);
	// need to check for type; for now just assume LLVM bitcode

	MemoryBuffer *buf = MemoryBuffer::getFile(filename);
	if (!buf) {
		Log::write("Couldn't load script file %s", filename);
		return false;
	}

	Module *m = ParseBitcodeFile(buf, *i->context);
	if (!m) { 
		Log::error("Couldn't parse bitcode file %s.", filename); 
		return false;
	}

	Log::debug("Link with main module.");
	loadChunk(m);

	Log::debug("Done loading %s.", filename);
	return true;
}

bool ScriptEngine::loadChunk(void *chunk) {
	Internals *i = (Internals *)internals;
	Module *m = (Module *)chunk;
	std::string msg;

	if (Linker::LinkModules(i->module, m, &msg)) {
		Log::write("LINK ERROR - %s", msg);
	}

	return true;
}

void ScriptEngine::callFunction(const char *name) {
	Internals *i = (Internals *)internals;

	Function *f = i->module->getFunction(name);
	std::vector<GenericValue> args;

	if (f) {
		i->exec->runFunction(f, args);
	} else {
		Log::error("Tried to execute non-existent function '%s'.", name);
	}
}

void ScriptEngine::debug() {
	/*
	Log::debug("Entering ScriptEngine::debug()");

	Internals *i = (Internals *)internals;
	Module *m = new Module("debug", *i->context);

	loadFile("test.llvm.bc");

	Log::debug(" >> create a function, test()");
		Function::Create(FunctionType::get(Type::getVoidTy(*i->context), false), Function::ExternalLinkage, "testCall", m);

		Function *f = cast<Function>(
			m->getOrInsertFunction(
				"test", 
				Type::getInt32Ty(*i->context), 
				Type::getInt32Ty(*i->context), ENDARGS
			)
		);
		Argument *arg = f->arg_begin();
		Value *one = ConstantInt::get(Type::getInt32Ty(*i->context), 1);

		BasicBlock *bb = BasicBlock::Create(*i->context, "EntryBlock", f);
		Value *sum = BinaryOperator::CreateAdd(arg, one, "r", bb);

		CallInst::Create(m->getFunction("testCall"), "", bb);
		ReturnInst::Create(*i->context, sum, bb);
	Log::debug(" >> done creating test()");

	Log::debug("Linking in testing debug module.");
	loadChunk(m);
	Log::debug("Done!");
	
	Log::debug("Current module...");

	i->module->dump();
	
	Log::debug(" >> execute functions");
		GenericValue gv;
		std::vector<GenericValue> args;

		args.clear();
		gv.IntVal = APInt(32,5);
		args.push_back(gv);
		gv = i->exec->runFunction(i->module->getFunction("test"), args);
		Log::debug("First call: %d", (int)gv.IntVal.getSExtValue());

		args[0].IntVal = APInt(32,7);
		gv = i->exec->runFunction(i->module->getFunction("test2"), args);
		Log::debug("Second call: %d", (int)gv.IntVal.getSExtValue());

		args.clear();
		gv = i->exec->runFunction(i->module->getFunction("testCall"), args);
		Log::debug("Third call: %d", (int)gv.IntVal.getSExtValue());
	Log::debug(" >> done executing functions");
	*/
}
